import sys
from pandas._config.config import option_context as option_context
from pandas._libs import Timestamp as Timestamp
from pandas._typing import FrameOrSeries as FrameOrSeries, Scalar as Scalar, _AxisType, _KeysArgType
from pandas.compat import set_function_name as set_function_name
from pandas.core import nanops as nanops
from pandas.core.arrays import Categorical as Categorical, DatetimeArray as DatetimeArray, try_cast_to_ea as try_cast_to_ea
from pandas.core.base import DataError as DataError, PandasObject as PandasObject, SelectionMixin as SelectionMixin
from pandas.core.dtypes.cast import maybe_downcast_to_dtype as maybe_downcast_to_dtype
from pandas.core.dtypes.common import ensure_float as ensure_float, is_datetime64_dtype as is_datetime64_dtype, is_extension_array_dtype as is_extension_array_dtype, is_integer_dtype as is_integer_dtype, is_numeric_dtype as is_numeric_dtype, is_object_dtype as is_object_dtype, is_scalar as is_scalar
from pandas.core.dtypes.missing import isna as isna, notna as notna
from pandas.core.frame import DataFrame as DataFrame
from pandas.core.generic import NDFrame as NDFrame
from pandas.core.groupby import base as base, ops as ops
from pandas.core.indexes.api import CategoricalIndex as CategoricalIndex, Index as Index, MultiIndex as MultiIndex
from pandas.core.series import Series as Series
from pandas.core.sorting import get_group_index_sorter as get_group_index_sorter
from pandas.errors import AbstractMethodError as AbstractMethodError
from pandas.util._decorators import Appender as Appender, Substitution as Substitution, cache_readonly as cache_readonly
from typing import Any, Callable, Dict, Generator, List, Optional, Tuple, Union
if sys.version_info >= (3, 8):
    from typing import Literal
else:
    from typing_extensions import Literal


class GroupByPlot(PandasObject):
    def __init__(self, groupby: Any) -> None: ...
    def __call__(self, *args: Any, **kwargs: Any): ...
    def __getattr__(self, name: str) -> Any: ...


class _GroupBy(PandasObject, SelectionMixin):
    level: Any = ...
    as_index: Any = ...
    keys: Any = ...
    sort: Any = ...
    group_keys: Any = ...
    squeeze: Any = ...
    observed: Any = ...
    mutated: Any = ...
    obj: Any = ...
    axis: Any = ...
    grouper: Any = ...
    exclusions: Any = ...
    def __init__(self, obj: NDFrame, keys: Optional[_KeysArgType]=..., axis: int=..., level: Any=..., grouper: Optional[ops.BaseGrouper]=..., exclusions: Any=..., selection: Any=..., as_index: bool=..., sort: bool=..., group_keys: bool=..., squeeze: bool=..., observed: bool=..., mutated: bool=...) -> None: ...
    def __len__(self) -> int: ...
    @property
    def groups(self) -> Dict[str, str]: ...
    @property
    def ngroups(self): ...
    @property
    def indices(self) -> Dict[str, Index]: ...
    def __getattr__(self, attr: str) -> Any: ...
    def pipe(self, func: Callable, *args, **kwargs) -> Any: ...
    plot: Any = ...
    def get_group(self, name: Any, obj: Optional[DataFrame] = ...) -> DataFrame: ...
    def __iter__(self) -> Generator[Tuple[str, Any], None, None]: ...
    def apply(self, func: Callable, *args, **kwargs) -> Union[Series, DataFrame]: ...
    def transform(self, func: Callable, *args, **kwargs): ...


class GroupBy(_GroupBy):
    def any(self, skipna: bool=...) -> bool: ...
    def all(self, skipna: bool=...) -> bool: ...
    def count(self) -> Union[Series, DataFrame]: ...
    def mean(self, **kwargs) -> Union[Series, DataFrame]: ...
    def median(self, **kwargs) -> Union[Series, DataFrame]: ...
    def std(self, ddof: int = ...) -> Union[Series, DataFrame]: ...
    def var(self, ddof: int = ...) -> Union[Series, DataFrame]: ...
    def sem(self, ddof: int = ...) -> Union[Series, DataFrame]: ...
    def size(self) -> Series: ...
    def ohlc(self) -> DataFrame: ...
    def describe(self, **kwargs) -> Union[Series, DataFrame]: ...
    def resample(self, rule: Any, *args: Any, **kwargs: Any): ...
    def rolling(self, *args: Any, **kwargs: Any): ...
    def expanding(self, *args: Any, **kwargs: Any): ...
    def pad(self, limit: Optional[Any] = ...): ...
    def ffill(self, limit: Optional[int] = ...) -> Union[Series, DataFrame]: ...
    def backfill(self, limit: Optional[Any] = ...): ...
    def bfill(self, limit: Optional[int] = ...) -> Union[Series, DataFrame]: ...
    def nth(self, n: Union[int, List[int]], dropna: Optional[str] = ...) -> Union[Series, DataFrame]: ...
    def quantile(self, q: Any=..., interpolation: str=...) -> Any: ...
    def ngroup(self, ascending: bool = ...) -> Series: ...
    def cumcount(self, ascending: bool = ...) -> Series: ...
    def rank(
        self, method: str = ..., ascending: bool = ..., na_option: str = ..., pct: bool = ..., axis: int = ...,
    ) -> DataFrame: ...
    def cummax(self, axis: _AxisType = ..., **kwargs) -> Union[Series, DataFrame]: ...
    def cummin(self, axis: _AxisType = ..., **kwargs) -> Union[Series, DataFrame]: ...
    def cumprod(self, axis: _AxisType = ..., **kwargs) -> Union[Series, DataFrame]: ...
    def cumsum(self, axis: _AxisType = ..., **kwargs) -> Union[Series, DataFrame]: ...
    def shift(self, periods: int = ..., freq: Optional[Any] = ..., axis: int = ..., fill_value: Optional[Any] = ...): ...
    def pct_change(
        self, periods: int = ..., fill_method: str = ..., limit: Any = ..., freq: Any = ..., axis: _AxisType = ...,
    ) -> Union[Series, DataFrame]: ...
    def head(self, n: int = ...) -> Union[Series, DataFrame]: ...
    def tail(self, n: int = ...) -> Union[Series, DataFrame]: ...
    # Surplus methodss from original pylance stubs; should they go away?
    def first(self, **kwargs) -> Union[Series, DataFrame]: ...
    def last(self, **kwargs) -> Union[Series, DataFrame]: ...
    def max(self, **kwargs) -> Union[Series, DataFrame]: ...
    def min(self, **kwargs) -> Union[Series, DataFrame]: ...
    def prod(self, **kwargs) -> Union[Series, DataFrame]: ...
    def sum(self, **kwargs) -> Union[Series, DataFrame]: ...


def get_groupby(obj: NDFrame, by: Optional[_KeysArgType]=..., axis: int=..., level: Any=..., grouper: Optional[ops.BaseGrouper]=..., exclusions: Any=..., selection: Any=..., as_index: bool=..., sort: bool=..., group_keys: bool=..., squeeze: bool=..., observed: bool=..., mutated: bool=...) -> GroupBy: ...
