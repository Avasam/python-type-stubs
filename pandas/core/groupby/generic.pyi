from matplotlib.axes import Axes as PlotAxes, SubplotBase as AxesSubplot
import numpy as np
import sys
#from pandas._libs import Timestamp as Timestamp, lib as lib
from pandas._typing import FrameOrSeries as FrameOrSeries, AxisType, DType, Level
#from pandas.core.base import DataError as DataError, SpecificationError as SpecificationError
#from pandas.core.construction import create_series_with_explicitDType as create_series_with_explicitDType
#from pandas.core.dtypes.cast import maybe_convert_objects as maybe_convert_objects, maybe_downcast_numeric as maybe_downcast_numeric, maybe_downcast_toDType as maybe_downcast_toDType
#from pandas.core.dtypes.common import ensure_int64 as ensure_int64, ensure_platform_int as ensure_platform_int, is_bool as is_bool, is_dict_like as is_dict_like, is_integerDType as is_integerDType, is_intervalDType as is_intervalDType, is_list_like as is_list_like, is_numericDType as is_numericDType, is_objectDType as is_objectDType, is_scalar as is_scalar, needs_i8_conversion as needs_i8_conversion
#from pandas.core.dtypes.missing import isna as isna, notna as notna
from pandas.core.frame import DataFrame as DataFrame
#from pandas.core.generic import ABCDataFrame as ABCDataFrame, ABCSeries as ABCSeries, NDFrame as NDFrame
#from pandas.core.groupby import base as base
from pandas.core.groupby.groupby import GroupBy as GroupBy #, get_groupby as get_groupby
from pandas.core.groupby.grouper import Grouper as Grouper
#from pandas.core.indexes.api import Index as Index, MultiIndex as MultiIndex, all_indexes_same as all_indexes_same
#from pandas.core.internals import Block as Block, BlockManager as BlockManager, make_block as make_block
from pandas.core.series import Series as Series
#from pandas.plotting import boxplot_frame_groupby as boxplot_frame_groupby
#from pandas.util._decorators import Appender as Appender, Substitution as Substitution
from typing import Any, Callable, Dict, FrozenSet, NamedTuple, Optional, Sequence, Tuple, Type, Union, overload
if sys.version_info >= (3, 8):
    from typing import Literal
else:
    from typing_extensions import Literal


class NamedAgg(NamedTuple):
    column: Any
    aggfunc: Any

AggScalar = Union[str, Callable[..., Any]]
ScalarResult: Any

def generate_property(name: str, klass: Type[FrameOrSeries]) -> Any: ...
def pin_whitelisted_properties(klass: Type[FrameOrSeries], whitelist: FrozenSet[str]) -> Any: ...

class SeriesGroupBy(GroupBy):
    def apply(self, func: Any, *args: Any, **kwargs: Any): ...
    def aggregate(self, func: Optional[Any] = ..., *args: Any, **kwargs: Any): ...
    agg = aggregate
    def transform(self, func: Any, *args: Any, **kwargs: Any): ...
    def filter(self, func: Any, dropna: bool = ..., *args: Any, **kwargs: Any): ...
    def nunique(self, dropna: bool = ...) -> Series: ...
    def describe(self, **kwargs) -> Series[np.double64]: ...
    def value_counts(
        self, normalize: bool = ..., sort: bool = ..., ascending: bool = ..., bins: Any = ..., dropna: bool = ...,
    ) -> DataFrame: ...
    def count(self) -> Series[DType]: ...
    def pct_change(
        self, periods: int = ..., fill_method: str = ..., limit: Any = ..., freq: Any = ..., axis: AxisType = ...,
    ) -> Series[DType]: ...
    # Overrides and others from original pylance stubs
    @property
    def is_monotonic_increasing(self) -> bool: ...
    @property
    def is_monotonic_decreasing(self) -> bool: ...
    def __getitem__(self, item: str) -> Series[DType]: ...
    def bfill(self, limit: Optional[int] = ...) -> Series[DType]: ...
    def cummax(self, axis: AxisType = ..., **kwargs) -> Series[DType]: ...
    def cummin(self, axis: AxisType = ..., **kwargs) -> Series[DType]: ...
    def cumprod(self, axis: AxisType = ..., **kwargs) -> Series[DType]: ...
    def cumsum(self, axis: AxisType = ..., **kwargs) -> Series[DType]: ...
    def ffill(self, limit: Optional[int] = ...) -> Series[DType]: ...
    def first(self, **kwargs) -> Series[DType]: ...
    def head(self, n: int = ...) -> Series[DType]: ...
    def last(self, **kwargs) -> Series[DType]: ...
    def max(self, **kwargs) -> Series[DType]: ...
    def mean(self, **kwargs) -> Series[DType]: ...
    def median(self, **kwargs) -> Series[DType]: ...
    def min(self, **kwargs) -> Series[DType]: ...
    def nlargest(self, n: int = ..., keep: str = ...) -> Series[DType]: ...
    def nsmallest(self, n: int = ..., keep: str = ...) -> Series[DType]: ...
    def nth(self, n: Union[int, Sequence[int]], dropna: Optional[str] = ...) -> Series[DType]: ...


class DataFrameGroupBy(GroupBy):
    @overload
    def aggregate(self, arg: str, *args, **kwargs) -> DataFrame: ...
    @overload
    def aggregate(self, arg: Dict, *args, **kwargs) -> DataFrame: ...
    @overload
    def aggregate(self, arg: Callable[[], Any], *args, **kwargs) -> DataFrame: ...
    @overload
    def agg(self, arg: str, *args, **kwargs) -> DataFrame: ...
    @overload
    def agg(self, arg: Dict, *args, **kwargs) -> DataFrame: ...
    @overload
    def agg(self, arg: Callable[[], Any], *args, **kwargs) -> DataFrame: ...
    def transform(self, func: Any, *args: Any, **kwargs: Any): ...
    def filter(self, func: Callable, dropna: bool = ..., *args, **kwargs) -> DataFrame: ...
    @overload
    def __getitem__(self, item: str) -> Series[DType]: ...
    @overload
    def __getitem__(self, item: Sequence[str]) -> DataFrame: ...
    def count(self) -> DataFrame: ...
    def nunique(self, dropna: bool = ...) -> DataFrame: ...
    def boxplot(
        self,
        grouped: DataFrame,
        subplots: bool = ...,
        column: Optional[Union[str, Sequence]] = ...,
        fontsize: Union[int, str] = ...,
        rot: float = ...,
        grid: bool = ...,
        ax: Optional[PlotAxes] = ...,
        figsize: Optional[Tuple[float, float]] = ...,
        layout: Optional[Tuple[int, int]] = ...,
        sharex: bool = ...,
        sharey: bool = ...,
        bins: Union[int, Sequence] = ...,
        backend: Optional[str] = ...,
        **kwargs
    ) -> Union[AxesSubplot, Sequence[AxesSubplot]]: ...
    # Overrides and others from original pylance stubs
    ## These are "properties" but properties can't have all these arguments?!
    def corr(self, method: Union[str, Callable], min_periods: int = ...) -> DataFrame: ...
    def cov(self, min_periods: int = ...) -> DataFrame: ...
    def diff(self, periods: int = ..., axis: AxisType = ...) -> DataFrame: ...


    def bfill(self, limit: Optional[int] = ...) -> DataFrame: ...

    def corrwith(self, other: DataFrame, axis: AxisType = ..., drop: bool = ..., method: str = ...,) -> Series: ...

    def cummax(self, axis: AxisType = ..., **kwargs) -> DataFrame: ...
    def cummin(self, axis: AxisType = ..., **kwargs) -> DataFrame: ...
    def cumprod(self, axis: AxisType = ..., **kwargs) -> DataFrame: ...
    def cumsum(self, axis: AxisType = ..., **kwargs) -> DataFrame: ...
    def describe(self, **kwargs) -> DataFrame: ...
    def ffill(self, limit: Optional[int] = ...) -> DataFrame: ...
    @overload
    def fillna(
        self,
        value: Any,
        method: Optional[str] = ...,
        axis: AxisType = ...,
        limit: Optional[int] = ...,
        downcast: Optional[Dict] = ...,
        *,
        inplace: Literal[True]
    ) -> None: ...
    @overload
    def fillna(
        self,
        value: Any,
        method: Optional[str] = ...,
        axis: AxisType = ...,
        inplace: Literal[False] = ...,
        limit: Optional[int] = ...,
        downcast: Optional[Dict] = ...,
    ) -> DataFrame: ...

    def first(self, **kwargs) -> DataFrame: ...
    def head(self, n: int = ...) -> DataFrame: ...
    def hist(
        self,
        data: DataFrame,
        column: Optional[Union[str, Sequence]] = ...,
        by: Any = ...,
        grid: bool = ...,
        xlabelsize: Optional[int] = ...,
        xrot: Optional[float] = ...,
        ylabelsize: Optional[int] = ...,
        yrot: Optional[float] = ...,
        ax: Optional[PlotAxes] = ...,
        sharex: bool = ...,
        sharey: bool = ...,
        figsize: Optional[Tuple[float, float]] = ...,
        layout: Optional[Tuple[int, int]] = ...,
        bins: Union[int, Sequence] = ...,
        backend: Optional[str] = ...,
        **kwargs
    ) -> Union[AxesSubplot, Sequence[AxesSubplot]]: ...
    def idxmax(self, axis: AxisType = ..., skipna: bool = ...) -> Series: ...
    def idxmin(self, axis: AxisType = ..., skipna: bool = ...) -> Series: ...
    def last(self, **kwargs) -> DataFrame: ...
    @overload
    def mad(
        self,
        axis: AxisType = ...,
        skipna: bool = ...,
        numeric_only: Optional[bool] = ...,
        *,
        level: Level,
        **kwargs
    ) -> DataFrame: ...
    @overload
    def mad(
        self,
        axis: AxisType = ...,
        skipna: bool = ...,
        level: None = ...,
        numeric_only: Optional[bool] = ...,
        **kwargs
    ) -> Series: ...
    def max(self, **kwargs) -> DataFrame: ...
    def mean(self, **kwargs) -> DataFrame: ...
    def median(self, **kwargs) -> DataFrame: ...
    def min(self, **kwargs) -> DataFrame: ...
    def nth(self, n: Union[int, Sequence[int]], dropna: Optional[str] = ...) -> DataFrame: ...

    def pct_change(
        self, periods: int = ..., fill_method: str = ..., limit: Any = ..., freq: Any = ..., axis: AxisType = ...,
    ) -> DataFrame: ...
    def prod(self, **kwargs) -> DataFrame: ...
    def quantile(self, q: float = ..., interpolation: str = ...) -> DataFrame: ...
    def rank(
        self, method: str = ..., ascending: bool = ..., na_option: str = ..., pct: bool = ..., axis: AxisType = ...,
    ) -> DataFrame: ...
    def resample(self, rule: Any, *args, **kwargs) -> Grouper: ...
    def sem(self, ddof: int = ...) -> DataFrame: ...
    def shift(
        self, periods: int = ..., freq: str = ..., axis: AxisType = ..., fill_value: Any = ...,
    ) -> DataFrame: ...
    def size(self) -> Series[int]: ...
    @overload
    def skew(
        self, axis: AxisType = ..., skipna: bool = ..., numeric_only: bool = ..., *, level: Level, **kwargs
    ) -> DataFrame: ...
    @overload
    def skew(
        self, axis: AxisType = ..., skipna: bool = ..., level: None = ..., numeric_only: bool = ..., **kwargs
    ) -> Series: ...
    def std(self, ddof: int = ...) -> DataFrame: ...
    def sum(self, **kwargs) -> DataFrame: ...
    def tail(self, n: int = ...) -> DataFrame: ...
    def take(self, indices: Sequence, axis: AxisType = ..., **kwargs) -> DataFrame: ...
    def tshift(self, periods: int, freq: Any = ..., axis: AxisType = ...) -> DataFrame: ...
    def var(self, ddof: int = ...) -> DataFrame: ...

