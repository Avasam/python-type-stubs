# Merge from pylance done
from pandas2.core import Index
import numpy as np
from pandas._config import get_option as get_option
from pandas._typing import ArrayLike as ArrayLike, Dtype as Dtype, Ordered as Ordered, Scalar as Scalar
from pandas.core import ops as ops
from pandas.core.accessor import PandasDelegate as PandasDelegate, delegate_names as delegate_names
from pandas.core.algorithms import factorize as factorize, take as take, take_1d as take_1d, unique1d as unique1d
from pandas.core.arrays.base import ExtensionArray as ExtensionArray, try_cast_to_ea as try_cast_to_ea
from pandas.core.base import NoNewAttributesMixin as NoNewAttributesMixin, PandasObject as PandasObject
from pandas.core.construction import array as array, extract_array as extract_array, sanitize_array as sanitize_array
from pandas.core.dtypes.cast import coerce_indexer_dtype as coerce_indexer_dtype, maybe_infer_to_datetimelike as maybe_infer_to_datetimelike
from pandas.core.dtypes.common import ensure_int64 as ensure_int64, ensure_object as ensure_object, ensure_platform_int as ensure_platform_int, is_categorical_dtype as is_categorical_dtype, is_datetime64_dtype as is_datetime64_dtype, is_dict_like as is_dict_like, is_dtype_equal as is_dtype_equal, is_extension_array_dtype as is_extension_array_dtype, is_integer_dtype as is_integer_dtype, is_iterator as is_iterator, is_list_like as is_list_like, is_object_dtype as is_object_dtype, is_scalar as is_scalar, is_sequence as is_sequence, is_timedelta64_dtype as is_timedelta64_dtype, needs_i8_conversion as needs_i8_conversion
from pandas.core.dtypes.dtypes import CategoricalDtype as CategoricalDtype
from pandas.core.dtypes.generic import ABCIndexClass as ABCIndexClass, ABCSeries as ABCSeries
from pandas.core.dtypes.inference import is_hashable as is_hashable
from pandas.core.dtypes.missing import isna as isna, notna as notna
from pandas.core.indexers import check_array_indexer as check_array_indexer, deprecate_ndim_indexing as deprecate_ndim_indexing
from pandas.core.missing import interpolate_2d as interpolate_2d
from pandas.core.ops.common import unpack_zerodim_and_defer as unpack_zerodim_and_defer
from pandas.core.sorting import nargsort as nargsort
from pandas.io.formats import console as console
from pandas.util._decorators import Appender as Appender, Substitution as Substitution, cache_readonly as cache_readonly, deprecate_kwarg as deprecate_kwarg
from pandas.util._validators import validate_bool_kwarg as validate_bool_kwarg, validate_fillna_kwargs as validate_fillna_kwargs
from typing import Any, List, Literal, Optional, Sequence, overload

def contains(cat: Any, key: Any, container: Any): ...

class Categorical(ExtensionArray, PandasObject):
    __array_priority__: int = ...
    def __init__(self, values: Sequence[Any], categories: Optional[Any] = ..., ordered: Optional[bool] = ..., dtype: Optional[CategoricalDtype] = ..., fastpath: bool = ...) -> None: ...
    @property
    def categories(self): ...
    @categories.setter
    def categories(self, categories: Any) -> None: ...
    @property
    def ordered(self) -> Ordered: ...
    @property
    def dtype(self) -> CategoricalDtype: ...
    def copy(self) -> Categorical: ...
    def astype(self, dtype: Dtype, copy: bool=...) -> ArrayLike: ...
    def size(self) -> int: ...
    def itemsize(self) -> int: ...
    def tolist(self) -> List[Scalar]: ...
    to_list: Any = ...
    @classmethod
    def from_codes(cls, codes: Sequence[int], categories: Optional[Index] = ..., ordered: Optional[bool] = ..., dtype: Optional[CategoricalDtype] = ..., fastpath: bool = ...) -> Categorical: ...
    @property
    def codes(self) -> List[int]: ...
    @overload
    def set_ordered(self, value: Any, inplace: Literal[True]) -> Categorical: ...
    @overload
    def set_ordered(self, value: Any, inplace: Literal[False]) -> None: ...
    @overload
    def as_ordered(self, inplace: Literal[True]) -> Categorical: ...
    @overload
    def as_ordered(self, inplace: Literal[False]) -> None: ...
    @overload    
    def as_unordered(self, inplace: Literal[True]) -> Categorical: ...
    @overload
    def as_unordered(self, inplace: Literal[False] = ...) -> Categorical: ...
    @overload
    def set_categories(self, new_categories: Any, ordered: Optional[Any] = ..., rename: bool = ..., *, inplace: Literal[True]) -> Categorical: ...
    @overload
    def set_categories(self, new_categories: Any, ordered: Optional[Any] = ..., rename: bool = ..., inplace: Literal[False] = ...): ...
    @overload
    def rename_categories(self, new_categories: Any, inplace: Literal[True]) -> Categorical: ...
    @overload
    def rename_categories(self, new_categories: Any, inplace: Literal[False] = ...) -> None: ...
    @overload
    def reorder_categories(self, new_categories: Any, ordered: Optional[Any] = ..., *, inplace: Literal[True]) -> Categorical: ...
    @overload
    def reorder_categories(self, new_categories: Any, ordered: Optional[Any] = ..., inplace: Literal[False] = ...): ...
    @overload
    def add_categories(self, new_categories: Any, inplace: Literal[True]) -> Categorical: ...
    @overload
    def add_categories(self, new_categories: Any, inplace: Literal[False] = ...): ...
    @overload
    def remove_categories(self, removals: Any, inplace: Literal[True]) -> Categorical: ...
    @overload
    def remove_categories(self, removals: Any, inplace: Literal[False] = ...) -> None: ...
    @overload
    def remove_unused_categories(self, inplace: Literal[True]) -> Categorical: ...
    @overload
    def remove_unused_categories(self, inplace: Literal[False] = ...): ...
    def map(self, mapper: Any): ...
    __eq__: Any = ...
    __ne__: Any = ...
    __lt__: Any = ...
    __gt__: Any = ...
    __le__: Any = ...
    __ge__: Any = ...
    @property
    def shape(self): ...
    def shift(self, periods: Any, fill_value: Optional[Any] = ...): ...
    def __array__(self, dtype: Any=...) -> np.ndarray: ...
    def __array_ufunc__(self, ufunc: Any, method: Any, *inputs: Any, **kwargs: Any): ...
    @property
    def T(self): ...
    @property
    def nbytes(self): ...
    def memory_usage(self, deep: bool = ...): ...
    def searchsorted(self, value: Any, side: str = ..., sorter: Optional[Any] = ...): ...
    def isna(self): ...
    isnull: Any = ...
    def notna(self): ...
    notnull: Any = ...
    def put(self, *args: Any, **kwargs: Any) -> None: ...
    def dropna(self): ...
    def value_counts(self, dropna: bool = ...): ...
    def check_for_ordered(self, op: Any) -> None: ...
    def argsort(self, ascending: bool = ..., kind: str = ..., *args: Any, **kwargs: Any): ...
    def sort_values(self, inplace: bool = ..., ascending: bool = ..., na_position: str = ...): ...
    def view(self, dtype: Optional[Any] = ...): ...
    def to_dense(self): ...
    def fillna(self, value: Optional[Any] = ..., method: Optional[Any] = ..., limit: Optional[Any] = ...): ...
    def take(self, indexer: Any, allow_fill: bool=..., fill_value: Any=...) -> Any: ...
    def take_nd(self, indexer: Any, allow_fill: bool=..., fill_value: Any=...) -> Any: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Any: ...
    def __contains__(self, key: Any) -> bool: ...
    def __getitem__(self, key: Any): ...
    def __setitem__(self, key: Any, value: Any) -> None: ...
    def min(self, skipna: bool = ...): ...
    def max(self, skipna: bool = ...): ...
    def mode(self, dropna: bool = ...): ...
    def unique(self): ...
    def equals(self, other: Any): ...
    def is_dtype_equal(self, other: Any): ...
    def describe(self): ...
    def repeat(self, repeats: Any, axis: Optional[Any] = ...): ...
    def isin(self, values: Any): ...
    @overload
    def replace(self, to_replace: Any, value: Any, inplace: Literal[True]) -> Categorical: ...
    @overload
    def replace(self, to_replace: Any, value: Any, inplace: Literal[False]=...) -> None: ...

class CategoricalAccessor(PandasDelegate, PandasObject, NoNewAttributesMixin):
    def __init__(self, data: Any) -> None: ...
    @property
    def codes(self) -> Sequence[int]: ...

def factorize_from_iterable(values: Any): ...
def factorize_from_iterables(iterables: Any): ...
