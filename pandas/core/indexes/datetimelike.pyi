from pandas._libs import NaT as NaT, iNaT as iNaT, lib as lib
from pandas._libs.algos import unique_deltas as unique_deltas
from pandas._libs.tslibs import timezones as timezones
from pandas.core import algorithms as algorithms
from pandas.core.accessor import PandasDelegate as PandasDelegate
from pandas.core.arrays import DatetimeArray as DatetimeArray, ExtensionArray as ExtensionArray, TimedeltaArray as TimedeltaArray
from pandas.core.arrays.datetimelike import DatetimeLikeArrayMixin as DatetimeLikeArrayMixin
from pandas.core.dtypes.common import ensure_int64 as ensure_int64, is_bool_dtype as is_bool_dtype, is_categorical_dtype as is_categorical_dtype, is_dtype_equal as is_dtype_equal, is_float as is_float, is_integer as is_integer, is_list_like as is_list_like, is_period_dtype as is_period_dtype, is_scalar as is_scalar, needs_i8_conversion as needs_i8_conversion
from pandas.core.dtypes.concat import concat_compat as concat_compat
from pandas.core.dtypes.generic import ABCIndex as ABCIndex, ABCIndexClass as ABCIndexClass, ABCSeries as ABCSeries
from pandas.core.dtypes.missing import isna as isna
from pandas.core.indexes.base import Index as Index
from pandas.core.indexes.extension import ExtensionIndex as ExtensionIndex, inherit_names as inherit_names, make_wrapped_arith_op as make_wrapped_arith_op
from pandas.core.indexes.numeric import Int64Index as Int64Index
from pandas.core.ops import get_op_result_name as get_op_result_name
from pandas.core.tools.timedeltas import to_timedelta as to_timedelta
from pandas.errors import AbstractMethodError as AbstractMethodError
from pandas.tseries.frequencies import DateOffset as DateOffset, to_offset as to_offset
from pandas.util._decorators import Appender as Appender, cache_readonly as cache_readonly
from typing import Any, List, Optional

class DatetimeIndexOpsMixin(ExtensionIndex):
    freq: Optional[DateOffset]
    freqstr: Optional[str]
    hasnans: Any = ...
    @property
    def is_all_dates(self) -> bool: ...
    @property
    def values(self): ...
    def __array_wrap__(self, result: Any, context: Optional[Any] = ...): ...
    def equals(self, other: Any) -> bool: ...
    def __contains__(self, key: Any): ...
    def sort_values(self, return_indexer: bool = ..., ascending: bool = ...): ...
    def take(self, indices: Any, axis: int = ..., allow_fill: bool = ..., fill_value: Optional[Any] = ..., **kwargs: Any): ...
    def tolist(self) -> List: ...
    def min(self, axis: Optional[Any] = ..., skipna: bool = ..., *args: Any, **kwargs: Any): ...
    def argmin(self, axis: Optional[Any] = ..., skipna: bool = ..., *args: Any, **kwargs: Any): ...
    def max(self, axis: Optional[Any] = ..., skipna: bool = ..., *args: Any, **kwargs: Any): ...
    def argmax(self, axis: Optional[Any] = ..., skipna: bool = ..., *args: Any, **kwargs: Any): ...
    __add__: Any = ...
    __radd__: Any = ...
    __sub__: Any = ...
    __rsub__: Any = ...
    __pow__: Any = ...
    __rpow__: Any = ...
    __mul__: Any = ...
    __rmul__: Any = ...
    __floordiv__: Any = ...
    __rfloordiv__: Any = ...
    __mod__: Any = ...
    __rmod__: Any = ...
    __divmod__: Any = ...
    __rdivmod__: Any = ...
    __truediv__: Any = ...
    __rtruediv__: Any = ...
    def isin(self, values: Any, level: Optional[Any] = ...): ...
    def where(self, cond: Any, other: Optional[Any] = ...): ...
    def shift(self, periods: int = ..., freq: Optional[Any] = ...): ...
    def delete(self, loc: Any): ...

class DatetimeTimedeltaMixin(DatetimeIndexOpsMixin, Int64Index):
    def difference(self, other: Any, sort: Optional[Any] = ...): ...
    def intersection(self, other: Any, sort: bool = ...): ...
    def join(self, other: Any, how: str=..., level: Any=..., return_indexers: Any=..., sort: Any=...) -> Any: ...

class DatetimelikeDelegateMixin(PandasDelegate): ...
