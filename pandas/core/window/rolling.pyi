from core.frame import DataFrame
from core.series import Series
from pandas._typing import Axis as Axis, FrameOrSeries as FrameOrSeries, Scalar as Scalar
from pandas.core.base import PandasObject as PandasObject, SelectionMixin as SelectionMixin, ShallowMixin as ShallowMixin
from pandas.core.indexes.api import Index as Index
from pandas.core.window.common import WindowGroupByMixin as WindowGroupByMixin
from typing import Callable, Dict, Optional, Set, Tuple, Union

class _Window(PandasObject, ShallowMixin, SelectionMixin):
    exclusions: Set[str] = ...
    obj = ...
    on = ...
    closed = ...
    window = ...
    min_periods = ...
    center = ...
    win_type = ...
    win_freq = ...
    axis = ...
    def __init__(self, obj, window=..., min_periods: Optional[int]=..., center: Optional[bool]=..., win_type: Optional[str]=..., axis: Axis=..., on: Optional[Union[str, Index]]=..., closed: Optional[str]=..., **kwargs) -> None: ...
    @property
    def is_datetimelike(self) -> Optional[bool]: ...
    @property
    def is_freq_type(self) -> bool: ...
    def validate(self) -> None: ...
    def __getattr__(self, attr: str) : ...
    def __iter__(self) : ...
    def aggregate(self, func: Optional[Callable] = ..., *args, **kwargs) -> Union[Scalar, Series, DataFrame]: ...
    agg = ...

class Window(_Window):
    def validate(self) -> None: ...
    def aggregate(self, func: Optional[Callable] = ..., *args, **kwargs) -> Union[Scalar, Series, DataFrame]: ...
    agg = ...
    def sum(self, *args, **kwargs): ...
    def mean(self, *args, **kwargs): ...
    def var(self, ddof: int = ..., *args, **kwargs): ...
    def std(self, ddof: int = ..., *args, **kwargs): ...

class _Rolling(_Window): ...

class _Rolling_and_Expanding(_Rolling):
    def count(self): ...
    def apply(self, func, raw: bool=..., engine: str=..., engine_kwargs: Optional[Dict]=..., args: Optional[Tuple]=..., kwargs: Optional[Dict]=...) : ...
    def sum(self, *args, **kwargs): ...
    def max(self, *args, **kwargs): ...
    def min(self, *args, **kwargs): ...
    def mean(self, *args, **kwargs): ...
    def median(self, **kwargs): ...
    def std(self, ddof: int = ..., *args, **kwargs): ...
    def var(self, ddof: int = ..., *args, **kwargs): ...
    def skew(self, **kwargs): ...
    def kurt(self, **kwargs): ...
    def quantile(self, quantile, interpolation: str = ..., **kwargs): ...
    def cov(self, other = ..., pairwise = ..., ddof: int = ..., **kwargs): ...
    def corr(self, other = ..., pairwise = ..., **kwargs): ...

class Rolling(_Rolling_and_Expanding):
    def is_datetimelike(self) -> bool: ...
    win_freq = ...
    window = ...
    win_type: str = ...
    min_periods: int = ...
    def validate(self) -> None: ...
    def aggregate(self, func, *args, **kwargs): ...
    agg = ...
    def count(self): ...
    def apply(self, func, raw: bool = ..., engine: str = ..., engine_kwargs = ..., args = ..., kwargs = ...): ...
    def sum(self, *args, **kwargs): ...
    def max(self, *args, **kwargs): ...
    def min(self, *args, **kwargs): ...
    def mean(self, *args, **kwargs): ...
    def median(self, **kwargs): ...
    def std(self, ddof: int = ..., *args, **kwargs): ...
    def var(self, ddof: int = ..., *args, **kwargs): ...
    def skew(self, **kwargs): ...
    def kurt(self, **kwargs): ...
    def quantile(self, quantile, interpolation: str = ..., **kwargs): ...
    def cov(self, other = ..., pairwise = ..., ddof: int = ..., **kwargs): ...
    def corr(self, other = ..., pairwise = ..., **kwargs): ...

class RollingGroupby(WindowGroupByMixin, Rolling): ...
