"""
This type stub file was generated by pyright.
"""

import re as _re
from typing import Iterable, Type

"""
IEEE 64-bit EUI (Extended Unique Indentifier) logic.
"""
AF_EUI64 = 64
width = 64
family = AF_EUI64
family_name = "EUI-64"
version = 64
max_int = 2 ** width - 1


class eui64_base(object):
    """A standard IEEE EUI-64 dialect class."""

    word_size: int = ...
    num_words: int = ...
    max_word: int = ...
    word_sep: str = ...
    word_fmt: str = ...
    word_base: int = ...


class eui64_unix(eui64_base):
    """A UNIX-style MAC address dialect class."""

    word_size: int = ...
    num_words: int = ...
    word_sep: str = ...
    word_fmt: str = ...
    word_base: int = ...


class eui64_unix_expanded(eui64_unix):
    """A UNIX-style MAC address dialect class with leading zeroes."""

    word_fmt: str = ...


class eui64_cisco(eui64_base):
    """A Cisco 'triple hextet' MAC address dialect class."""

    word_size: int = ...
    num_words: int = ...
    word_sep: str = ...
    word_fmt: str = ...
    word_base: int = ...


class eui64_bare(eui64_base):
    """A bare (no delimiters) MAC address dialect class."""

    word_size: int = ...
    num_words: int = ...
    word_sep: str = ...
    word_fmt: str = ...
    word_base: int = ...


DEFAULT_EUI64_DIALECT = eui64_base
RE_EUI64_FORMATS = (
    "^" + ":".join(["([0-9A-F]{1,2})"] * 8) + "$",
    "^" + "-".join(["([0-9A-F]{1,2})"] * 8) + "$",
    "^" + ":".join(["([0-9A-F]{1,4})"] * 4) + "$",
    "^" + "-".join(["([0-9A-F]{1,4})"] * 4) + "$",
    "^" + r"\.".join(["([0-9A-F]{1,4})"] * 4) + "$",
    "^(" + "".join(["[0-9A-F]"] * 16) + ")$",
)
RE_EUI64_FORMATS = [_re.compile(_, _re.IGNORECASE) for _ in RE_EUI64_FORMATS]


def valid_str(addr: str) -> bool:
    """
    :param addr: An IEEE EUI-64 indentifier in string form.

    :return: ``True`` if EUI-64 indentifier is valid, ``False`` otherwise.
    """
    ...


def str_to_int(addr: str) -> int:
    """
    :param addr: An IEEE EUI-64 indentifier in string form.

    :return: An unsigned integer that is equivalent to value represented
        by EUI-64 string address formatted according to the dialect
    """
    ...


def int_to_str(int_val: int, dialect: Type[eui64_base] = ...):
    """
    :param int_val: An unsigned integer.

    :param dialect: (optional) a Python class defining formatting options

    :return: An IEEE EUI-64 identifier that is equivalent to unsigned integer.
    """
    ...


def int_to_packed(int_val: int) -> str:
    """
    :param int_val: the integer to be packed.

    :return: a packed string that is equivalent to value represented by an
    unsigned integer.
    """
    ...


def packed_to_int(packed_int: str) -> int:
    """
    :param packed_int: a packed string containing an unsigned integer.
        It is assumed that string is packed in network byte order.

    :return: An unsigned integer equivalent to value of network address
        represented by packed binary string.
    """
    ...


def valid_words(words, dialect: Type[eui64_base] = ...) -> bool:
    ...


def int_to_words(int_val: int, dialect: Type[eui64_base] = ...) -> Iterable[int]:
    ...


def words_to_int(words: Iterable[int], dialect: Type[eui64_base] = ...):
    ...


def valid_bits(bits: str, dialect: Type[eui64_base] = ...) -> bool:
    ...


def bits_to_int(bits: str, dialect: Type[eui64_base] = ...):
    ...


def int_to_bits(int_val: int, dialect: Type[eui64_base] = ...):
    ...


def valid_bin(bin_val: str, dialect: Type[eui64_base] = ...) -> bool:
    ...


def int_to_bin(int_val: int):
    ...


def bin_to_int(bin_val: str):
    ...

